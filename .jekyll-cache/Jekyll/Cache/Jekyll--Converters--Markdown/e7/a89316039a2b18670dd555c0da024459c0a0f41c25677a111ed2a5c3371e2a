I"F<h2 id="0-dispose-disposebag">0. Dispose, DisposeBag</h2>
<p>이번 포스팅에선 메모리 누수방지를 위해 무조건 필요한 <code class="language-plaintext highlighter-rouge">dispose</code>를 먼저 알아보고, 이후에 남은 생성 operator들을 알아보도록 하겠다.<br /></p>
<h3 id="1-dispose">1. Dispose</h3>
<p>지난 포스팅에서 Observable은 구독(subscribe)하지 않으면 어떠한 이벤트도 내지않는 sequence일 뿐이라고 말했다.<br />
<br />
만약 무한한 element를 방출하는 Observable일 경우 구독을 한 뒤 계속해서 이벤트를 방출할 텐데, 어떻게 구독을 멈출 수 있을까?<br />
<br />
바로 <code class="language-plaintext highlighter-rouge">dispose()</code>를 이용해 멈출 수 있다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">Observable</span><span class="o">.</span><span class="nf">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1">//Observable 생성</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span>    <span class="c1">//subscribe를 통해 이벤트 생성</span>
        <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="o">.</span><span class="nf">dispose</span><span class="p">()</span>          <span class="c1">//dispose 후에는 이벤트 방출 안됨</span>

<span class="cp">#=&gt; prints 1</span>
<span class="cp">#=&gt; prints 2</span>
<span class="cp">#=&gt; prints 3</span></code></pre></figure>

<p>다음과 같이 코드상으로 표현되진 않지만 무한한 element가 있을 경우 반드시 <code class="language-plaintext highlighter-rouge">dispose()</code>를 해야 이벤트가 종료된다.<br />
<br />
메모리 누수 방지를 위해선 항상 <code class="language-plaintext highlighter-rouge">dispose</code>해주어야 한다. (일종의 생명주기라 할 수 있음)</p>

<h3 id="2-disposebag">2. DisposeBag</h3>
<p>구독해제를 <code class="language-plaintext highlighter-rouge">dispose()</code>로 한다고 알았는데… <code class="language-plaintext highlighter-rouge">DisposeBag</code>은 무엇일까?<br />
<br />
일단 코드를 통해 보도록 하자.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">disposeBag</span> <span class="o">=</span> <span class="kt">DisposeBag</span><span class="p">()</span>

<span class="kt">Observable</span><span class="o">.</span><span class="nf">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="o">.</span><span class="n">subscribe</span><span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">disposed(by:)</code>는 <code class="language-plaintext highlighter-rouge">dispose()</code>와 동일하게 구독해제를 위해 작성하였다.<br />
<br />
<code class="language-plaintext highlighter-rouge">disposeBag</code>은 <code class="language-plaintext highlighter-rouge">disposed(by:)</code>를 통해 <code class="language-plaintext highlighter-rouge">disposable</code>타입으로 Observable을 받고, <code class="language-plaintext highlighter-rouge">disposeBag</code>이 할당해제를 할 때마다 담겨져 있는 모든 <code class="language-plaintext highlighter-rouge">disposable</code>들에게 <code class="language-plaintext highlighter-rouge">dispose()</code>를 호출한다.<br />
<br />
따라서 위 코드의 Observable은 발생하는 이벤트들을 print하고 구독 후 방출된 return 값들을 <code class="language-plaintext highlighter-rouge">disposeBag</code>에 추가하는 것이다.<br />
<br />
<code class="language-plaintext highlighter-rouge">dispose</code>와 <code class="language-plaintext highlighter-rouge">disposeBag</code>은 구독할 때 마다 할당하는 것 같아 불편해 보이지만, 끝나지 않는 Observable일 경우 메모리 누수가 일어나기 때문에 매번 Observable을 생성하면 <code class="language-plaintext highlighter-rouge">disposeBag</code>을 만드는게 무조건 필요하다.<br />
<br />
이후 하단의 예시에는 모두 <code class="language-plaintext highlighter-rouge">disposeBag</code>을 선언했다는 가정 하에 작성하도록 하겠다.</p>

<h2 id="1-create">1. create</h2>
<p><code class="language-plaintext highlighter-rouge">create</code>은 observer를 전달받아 <code class="language-plaintext highlighter-rouge">Disposable</code>을 반환하는 escaping 클로저이다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">// create 1</span>
<span class="kt">Observable</span><span class="o">.</span><span class="n">create</span> <span class="p">{</span> <span class="n">observer</span> <span class="o">-&gt;</span> <span class="kt">Disposable</span> <span class="k">in</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onCompleted</span><span class="p">()</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="kt">Disposables</span><span class="o">.</span><span class="nf">create</span><span class="p">()</span>
<span class="p">}</span>
<span class="o">.</span><span class="n">subscribe</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#=&gt; prints 1</span></code></pre></figure>

<p>다음과 같이 Observable을 생성하면 <code class="language-plaintext highlighter-rouge">1</code>만 출력된다. 이유는 무엇일까?<br />
<br />
바로 observer가 <code class="language-plaintext highlighter-rouge">1</code>을 next이벤트로 전달한 다음, completed이벤트를 통해 종료되어 그 다음 전달받은 element는 구독되지 않기 때문이다.<br />
<br />
그렇다면 completed이벤트와 유사하게 종료시키는 error이벤트는 어떻게 반응할까?</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">// create 2</span>
<span class="kd">enum</span> <span class="kt">MyError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">anError</span>
<span class="p">}</span>

<span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">create</span> <span class="p">{</span> <span class="n">observer</span> <span class="o">-&gt;</span> <span class="kt">Disposable</span> <span class="k">in</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onError</span><span class="p">(</span><span class="kt">MyError</span><span class="o">.</span><span class="n">anError</span><span class="p">)</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onCompleted</span><span class="p">()</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="kt">Disposables</span><span class="o">.</span><span class="nf">create</span><span class="p">()</span>
<span class="p">}</span>
<span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span>
    <span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onError</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"에러발생 : </span><span class="se">\(</span><span class="nv">$0</span><span class="o">.</span><span class="n">localizedDescription</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onCompleted</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"completed!"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onDisposed</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"disposed!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
<span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>

<span class="cp">#=&gt; prints 1</span>
<span class="cp">#=&gt; prints 에러발생 : The operation couldn’t be completed. (__lldb_expr_25.MyError error 0.)</span>
<span class="cp">#=&gt; prints disposed!</span></code></pre></figure>

<p>임의의 에러 <code class="language-plaintext highlighter-rouge">anError</code>를 생성한 후 <code class="language-plaintext highlighter-rouge">create</code>로 Observable을 생성하였다.<br />
<br />
처음 nex이벤트로 전달된 <code class="language-plaintext highlighter-rouge">1</code>은 무사히 출력되었지만 이후 에러가 발생하고 completed이벤트까지 가지않고, 2 또한 출력되지 않았다.<br />
하지만 Observable이 종료되고 <code class="language-plaintext highlighter-rouge">disposed</code>가 실행된 것은 확인할 수 있다.<br />
<br />
자 그럼 error, completed, disposed 모두 생성하지 않고 Observable을 만들면 어떻게 될까?</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">Observable</span><span class="o">.</span><span class="n">create</span> <span class="p">{</span> <span class="n">observer</span> <span class="o">-&gt;</span> <span class="kt">Disposable</span> <span class="k">in</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="kt">Disposables</span><span class="o">.</span><span class="nf">create</span><span class="p">()</span>
<span class="p">}</span>
<span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span>
    <span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onError</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"에러발생 : </span><span class="se">\(</span><span class="nv">$0</span><span class="o">.</span><span class="n">localizedDescription</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onCompleted</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"completed!"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onDisposed</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"disposed!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="cp">#=&gt; prints 1</span>
<span class="cp">#=&gt; prints 2</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">diposed</code>, error, completed 이벤트 모두 없으므로 결과적으로 Observable은 종료되지 않고 메모리 누수가 발생할 것이다.<br />
<br />
따라서 반드시 Observable을 생성할 땐 <code class="language-plaintext highlighter-rouge">disposed</code>를 작성해주도록 하자.</p>

<h2 id="2-deferred">2. deferred</h2>
<p>deferred는 Observable을 만드는 대신에, 구독이 되기 전까지 Observable 생성을 지연하고 구독이 시작되면 새롭게 Observable을 제공하는 Observable Factory 형식이다.<br />
<br />
굉장히 이해하기 어려운 내용인데, 쉽게 풀어보면</p>
<ol>
  <li>구독하기 전엔 ‘대기상태의 Observable’</li>
  <li>구독을 시작하면 ‘진짜로 생성된 Observable’<br />
<br />
예시를 통해 확인하자.</li>
</ol>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nv">뒤집기</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span>

<span class="k">let</span> <span class="nv">factory</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Observable</span><span class="o">.</span><span class="n">deferred</span> <span class="p">{</span>
    <span class="n">뒤집기</span> <span class="o">=</span> <span class="o">!</span><span class="n">뒤집기</span>

    <span class="k">if</span> <span class="n">뒤집기</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Observable</span><span class="o">.</span><span class="nf">of</span><span class="p">(</span><span class="s">"👍"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Observable</span><span class="o">.</span><span class="nf">of</span><span class="p">(</span><span class="s">"👎"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="mi">3</span> <span class="p">{</span>
    <span class="n">factory</span><span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
    <span class="p">})</span>
        <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#=&gt; prints 👍</span>
<span class="cp">#=&gt; prints 👎</span>
<span class="cp">#=&gt; prints 👍</span>
<span class="cp">#=&gt; prints 👎</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">factory</code>는 처음 선언될 때 <code class="language-plaintext highlighter-rouge">deferred</code>된 Observable로 선언되었기 때문에 대기상태이다.<br />
<br />
그리고 Bool 타입인 <code class="language-plaintext highlighter-rouge">뒤집기</code> 변수는 처음엔 <code class="language-plaintext highlighter-rouge">false</code>이다.<br />
<br />
이후 구독됨에 따라 <code class="language-plaintext highlighter-rouge">factory</code>는 대기상태가 풀리면서 <code class="language-plaintext highlighter-rouge">deferred</code>내의 <code class="language-plaintext highlighter-rouge">뒤집기 = !뒤집기</code>가 실행되었기 때문에 <code class="language-plaintext highlighter-rouge">뒤집기 = true</code>가 되고, <code class="language-plaintext highlighter-rouge">👍</code>이 출력된다.<br />
<br />
그 다음 반복에서도 위와 같은 과정으로 <code class="language-plaintext highlighter-rouge">뒤집기</code>의 Bool값이 변하면서 출력된다.<br />
<br />
다시한번 정리하자면, Observable deferred는 Observable factory를 통해서 sequence를 생성할 수 있는 연산자이다.</p>

<h2 id="3-마무리">3. 마무리</h2>
<p>지금까지 두개의 포스팅을 통해 Observable의 기본이 되는 생성 Operator들과 dispose에 대해 알아보았다.<br />
<br />
다음은 Observable보다 조금 작은 개념인 Single, Maybe, Completable에 대해 알아보도록 하자.</p>

<p><br /><br /><br /><br />
출처 : 30개 프로젝트로 배우는 iOS 앱 개발 with Swift 초격차 패키지 Online - part 4. Github 앱 만들기</p>
:ET