I"<h2 id="1-observable-이란">1. Observable 이란</h2>

<p>지난 포스팅에서, RxSwift를 알아보았다.<br />
<br />
이번 포스팅에선 RxSwift의 한 구성요소인 Observable에 대해 알아보도록 하자.<br />
<br /></p>

<ul>
  <li>Observable이란?
    <blockquote>
      <p>제너럴타입의 객체로, <code class="language-plaintext highlighter-rouge">T</code>형태의 데이터 snapshot을 전달 할 수 있는 일련의 이벤트를 비동기적으로 생성하는 기능을 가짐.</p>
    </blockquote>
  </li>
</ul>

<p><br />
지난 포스팅 내용과 같이, <code class="language-plaintext highlighter-rouge">Observable</code>은 제너럴 타입의 객체이며 실시간으로 세 가지 유형의 이벤트를 방출한다.<br />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">Observable</code>은 일정 기간 동안 계속해서 이벤트를 생성하며 이러한 행동을 emit이라고 한다.<br />
<br />
세 가지 이벤트는 next, error, completed 세가지로 구성된다.<br />
<br />
중요한 점은 이 모든 이벤트들은 비동기적으로 발생한다는 것이다.</p>

<h2 id="2-observable의-생명주기">2. Observable의 생명주기</h2>
<p>생명주기를 보여줌에 앞서, Rx의 흐름에 따라 값을 표기하는 방식인 ‘marble diagram’ 으로 나타내도록 하겠다.</p>

<p><img width="328" src="https://user-images.githubusercontent.com/83946704/148389744-9a058c20-0e2e-49e3-936a-7bd1d3405137.png" /><br /></p>

<p>위의 marble diagram은 세 개의 Observable을 나타내었다.<br />
<br />
<code class="language-plaintext highlighter-rouge">Observable</code>은 각각의 next 이벤트를 통해서 요소(element)들을 방출하게 되는데, 첫번째와 두번째 <code class="language-plaintext highlighter-rouge">Observable</code>은 3개의 이벤트를 방출한 뒤 종료하게 된다.<br />
<br />
두번째 <code class="language-plaintext highlighter-rouge">Observable</code>의 diagram에서 맨 끝의 수직선은 completed 이벤트를 표현한 것이다.<br />
<br />
세번째 <code class="language-plaintext highlighter-rouge">Observable</code>은 다른것들과 다르게 error가 발생하였다(X로 표현됨).<br />
<br />
이벤트가 종료된 것은 앞서 두 <code class="language-plaintext highlighter-rouge">Observable</code>과 동일하지만 error를 통해 종료되었다는 차이점이 있다.</p>

<h3 id="2-1-observable">2-1. Observable</h3>
<p><code class="language-plaintext highlighter-rouge">Observable&lt;T&gt;</code>란?<br /></p>

<ol>
  <li>제너럴타입의 객체로, <code class="language-plaintext highlighter-rouge">T</code>형태의 데이터 snapshot을 전달 할 수 있는 일련의 이벤트를 비동기적으로 생성하는 기능을 가진다.</li>
  <li>하나 이상의 <code class="language-plaintext highlighter-rouge">observers</code>가 실시간으로 어떤 이벤트에 반응한다.</li>
  <li>세 가지 유형의 이벤트만 방출한다.</li>
</ol>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="kt">Event</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nf">next</span><span class="p">(</span><span class="kt">Element</span><span class="p">)</span>      <span class="c1">// Observable의 어떠한 다음 요소</span>
  <span class="k">case</span> <span class="nf">error</span><span class="p">(</span><span class="kt">Swift</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="c1">// 에러 이벤트</span>
  <span class="k">case</span> <span class="n">completed</span>          <span class="c1">// 최종완료 이벤트</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<code class="language-plaintext highlighter-rouge">observer</code>와 <code class="language-plaintext highlighter-rouge">Observable</code>만 있을 뿐, 다른 <code class="language-plaintext highlighter-rouge">delegate protocal</code>을 이용하거나 <code class="language-plaintext highlighter-rouge">class</code>간 통신을 위해 클로저를 사용할 필요가 없다.<br />
<br />
어느곳에서든 <code class="language-plaintext highlighter-rouge">Observable</code>을 선언하고 <code class="language-plaintext highlighter-rouge">Observable</code>을 수신할 수 있는 <code class="language-plaintext highlighter-rouge">observer</code>만 있다면 이벤트를 서로 수신할 수 있다.<br /></p>

<h3 id="2-2-operator">2-2. Operator</h3>
<p><code class="language-plaintext highlighter-rouge">Operator</code>란?<br />
수식과 같이 일정한 기능을 수행하면서 <code class="language-plaintext highlighter-rouge">Observable</code>에서 방출한 값을 기능에 맞춰 순서를 맞추고 조합해서 사용하는 것.<br />
<br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">//예시: 가로, 세로 화면전환의 경우</span>
<span class="kt">UIDevice</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">orientation</span>
  <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
      <span class="k">return</span> <span class="n">value</span> <span class="o">!=</span> <span class="o">.</span><span class="n">landscape</span>
  <span class="p">}</span>
  <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
      <span class="k">return</span> <span class="s">"세로로만 보겠습니다!"</span>
  <span class="p">}</span>
  <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">string</span> <span class="k">in</span>
      <span class="nf">showAlert</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>
  <span class="p">})</span></code></pre></figure>

<p><br />
코드를 통해 예시를 보자면,<br />
<code class="language-plaintext highlighter-rouge">UIDeive.rx.orientation</code>이 <code class="language-plaintext highlighter-rouge">Observable&lt;Orientation&gt;</code>타입을 가지는 하나의 <code class="language-plaintext highlighter-rouge">Observable</code>이다.<br />
<br />
하나의 <code class="language-plaintext highlighter-rouge">Observable</code>을 <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">subscribe</code>와 같은 연산자들이 각각의 결과값을 조합하고 계산한 다음 결과를 내뱉는 것.<br /></p>

<h3 id="2-3-scheduler">2-3. Scheduler</h3>
<p><code class="language-plaintext highlighter-rouge">Scheduler</code>란?<br />
RxSwift에서 dispatchQueue와 동일한 것으로 더욱 강력하고 사용하기 쉽다.<br />
<br />
여태 GCD를 이용해 <code class="language-plaintext highlighter-rouge">dispatchQueue</code>를 이용했다면, <code class="language-plaintext highlighter-rouge">Scheduler</code>는 <code class="language-plaintext highlighter-rouge">Main Scheduler</code>, <code class="language-plaintext highlighter-rouge">Background Scheduler</code>로 나뉘어서 사용됨.</p>

<h2 id="3-마무리">3. 마무리</h2>
<p>다음과 같이 RxSwift의 개념과 RxSwift를 이루는 요소들에 대해 알아보았다.<br />
<br />
RxSwift는 거의 필수적으로 알아야 하는 만큼 이번에 간단하게 알아본것을 넘어서 더욱 자세하게 구성요소들에 대해 알아보도록 포스팅을 이어가겠다.</p>

<p><br /><br /><br /><br />
출처 : 30개 프로젝트로 배우는 iOS 앱 개발 with Swift 초격차 패키지 Online - part 4. Github 앱 만들기</p>
:ET