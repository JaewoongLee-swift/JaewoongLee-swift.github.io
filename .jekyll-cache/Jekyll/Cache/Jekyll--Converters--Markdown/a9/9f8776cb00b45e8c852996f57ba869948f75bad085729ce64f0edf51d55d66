I"d<h2 id="1-arc">1. ARC</h2>
<p>ARC (Automatic Reference Counting)<br />
<br />
Swift는 ARC를 사용하여 앱의 메모리 사용량을 추적하고 관리한다.<br />
<br />
ARC는 어떠한 클래스 인스턴스가 더 이상 필요하지 않을 때 클래스 인스턴스에 할당된 메모리를 자동으로 해제한다.<br />
<br />
ARC는 메모리를 관리하기 위해 코드 부분 간의 관계에 대한 추가적인 정보를 요구할 수도 있다.<br />
<br />
ARC는 Reference Type인 class 인스턴스에만 적용된다.<br />
<br />
struct와 enum은 value type이기 때문에 reference로 저장 및 전달되지 않으며 ARC도 적용되지 않는다.<br />
<br /></p>

<h2 id="2-how-arc-works">2. How ARC Works</h2>
<p>class의 새 인스턴스를 만들 때마다 ARC는 해당 인스턴스에 대한 정보를 저장하기 위해 메모리를 할당한다.<br /><br />메모리에는 해당 인스턴스의 저장 프로퍼티, 인스턴스 타입에 대한 정보를 저장한다.<br /><br />인스턴스를 사용하다 더 이상 필요하지 않은 경우 ARC는 해당 인스턴스에서 사용하는 메모리를 해제해야 한다.<br /><br />쓸모없는 데이터를 메모리에 남겨두는 것은 비효율적이기 때문이다.<br /><br /></p>

<p>ARC가 인스턴스의 메모리를 해제하면 더 이상 해당 인스턴스의 프로퍼티에 접근하거나 인스턴스 메모리를 호출할 수 없다.<br /><br /> 만약 아직 사용중인 인스턴스를 ARC가 할당 해제한다면 앱이 충돌할 가능성이 있다.<br /><br /></p>

<p>따라서 ARC는 인스턴스가 언제까지 필요한지 알 수 있s도록 인스턴스를 참조하는 프로퍼티, 상수, 변수의 수를 추적한다.<br /><br /> 만약 하나 이상의 요소가 인스턴스를 참조하고 있다면 ARC는 할당을 취소하지 않는다.<br /><br /></p>

<p>이를 가능하게 하기 위해 프로퍼티, 상수, 변수에 클래스 인스턴스를 할당할 때 마다 강한 참조를 만든다. <br /><br />지금까지 아무런 생각 없이 할당했던 코드들은 모두 강한 참조가 자동으로 적용되었던 코드들이었다…!!<br /><br /></p>

<h2 id="3-arc-in-action">3. ARC in Action</h2>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s"> is being initialized."</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">deinit</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s"> is being deinitialized."</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">reference1</span><span class="p">:</span> <span class="kt">Person</span><span class="p">?</span>
<span class="k">var</span> <span class="nv">reference2</span><span class="p">:</span> <span class="kt">Person</span><span class="p">?</span>
<span class="k">var</span> <span class="nv">reference3</span><span class="p">:</span> <span class="kt">Person</span><span class="p">?</span>
<span class="c1">// 옵셔널로 선언했기 때문에 아직은 아무런 데이터가 없어 Person 인스턴스를 참조하지 않음</span>

<span class="n">reference1</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"이재웅"</span><span class="p">)</span> <span class="c1">// reference count : 1</span>
<span class="c1">//prints 이재웅 is being initialized.</span>
<span class="c1">//reference1과 Person 인스턴스 사이엔 강한 참조가 추가된다.</span></code></pre></figure>

<p>따라서 ARC는 Person 인스턴스가 메모리에 유지되고 해제되지 않도록 한다.<br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">reference2</span> <span class="o">=</span> <span class="n">reference1</span> <span class="c1">// reference count : 2</span>
<span class="n">reference3</span> <span class="o">=</span> <span class="n">reference1</span> <span class="c1">// reference count : 3</span>

<span class="n">reference1</span> <span class="o">=</span> <span class="kc">nil</span> <span class="c1">// reference count : 2</span>
<span class="n">reference2</span> <span class="o">=</span> <span class="kc">nil</span> <span class="c1">// reference count : 1</span></code></pre></figure>

<p>할당해제를 해보자. 두 개의 변수에 nil을 할당하여 강한 참조 두개를 제거할 수 있다. <br /><br />하지만 아직 1개의 강한 참조가 남아있기 때문에 deinit 메세지는 출력되지 않는다.<br /><br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">reference3</span> <span class="o">=</span> <span class="kc">nil</span> <span class="c1">// reference count : 0</span>
<span class="c1">//prints 이재웅 is being deinitialized.</span></code></pre></figure>

<p>마지막 변수에도 할당 해제를 해주면 참조 카운트가 0이되어 인스턴스가 메모리에서 해제된다.<br /><br /> 해제됨에 따라 deinit이 호출되어 메세지가 출력된다.<br /><br /></p>

<p>즉, 참조 카운트가 0이 되어야 메모리에서 해제될 수 있는것이다.<br /><br /></p>

<h2 id="4-strong-reference-cycles-between-class-instances">4. Strong Reference Cycles Between Class Instances</h2>
<p>위에서 본듯 강한 참조를 사용하면 문제가 발생할 수 있다.<br /><br /> 이 문제는 인스턴스에서 다른 인스턴스에 대해 강한 참조를 가지고 있을 때 참조를 한 인스턴스가 해제 되었는데도 불구하고 참조를 계속 유지하는 문제이다. <br /><br />이렇게 되면 필요하지 않은 데이터를 유지해야 하기 때문에 메모리 누수가 발생한다.<br /><br /> 이러한 문제는 weak 참조나 unowned 참조를 사용하여 해결할 수 있는데 우선 어떻게 문제가 발생하는지 살펴보자.<br /><br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">Learner</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">nickname</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">house</span><span class="p">:</span> <span class="kt">Accommodation</span><span class="p">?</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">nickname</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span> <span class="k">self</span><span class="o">.</span><span class="n">nickname</span> <span class="o">=</span> <span class="n">nickname</span> <span class="p">}</span>

    <span class="kd">deinit</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">nickname</span><span class="se">)</span><span class="s"> is being deinitialized."</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Accommodation</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">nickname</span><span class="p">:</span> <span class="kt">Learner</span><span class="p">?</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span> <span class="k">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span> <span class="p">}</span>

    <span class="kd">deinit</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"Apartment </span><span class="se">\(</span><span class="n">type</span><span class="se">)</span><span class="s"> is being deinitialized."</span><span class="p">)}</span>
<span class="p">}</span></code></pre></figure>

<p>다음 코드가 문제를 발생하는 코드. <br /><br />Learner 클래스의 house 프로퍼티는 Accommodation 클래스 인스턴스 타입이고 Accommodation 클래스의 nickname 프로퍼티는 Learner 클래스 인스턴스 타입이다. <br /><br />이 프로퍼티들은 옵셔널 타입으로 처음엔 nil이 할당된다.<br /><br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nv">curry</span><span class="p">:</span> <span class="kt">Learner</span><span class="p">?</span>
<span class="k">var</span> <span class="nv">residenceHall</span><span class="p">:</span> <span class="kt">Accommodation</span><span class="p">?</span>

<span class="n">curry</span> <span class="o">=</span> <span class="kt">Learner</span><span class="p">(</span><span class="nv">nickname</span><span class="p">:</span> <span class="s">"커리"</span><span class="p">)</span> <span class="c1">// Learner reference count : 1</span>
<span class="n">residenceHall</span> <span class="o">=</span> <span class="kt">Accommodation</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="s">"생활관"</span><span class="p">)</span> <span class="c1">// Accommodation reference count : 1</span></code></pre></figure>

<p>다음과 같은 클래스 인스턴스를 만들어보자. <br /><br />curry 변수에는 Learner 클래스의 인스턴스를 할당하고 residenceHall 변수에는 Accommodation 클래스의 인스턴스를 할당하였다.<br /><br /></p>

<p><img width="756" alt="var curry" src="https://user-images.githubusercontent.com/83946704/169653113-405a8dc0-5723-44b6-bcfd-80f35bd5c8d8.png" /><br />
(curry, residenceHall의 강한 참조 예시)<br /><br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">curry</span><span class="o">!.</span><span class="n">house</span> <span class="o">=</span> <span class="n">residenceHall</span> <span class="c1">// Accommodation reference count : 2</span>
<span class="n">residenceHall</span><span class="o">!.</span><span class="n">nickname</span> <span class="o">=</span> <span class="n">curry</span> <span class="c1">// Learner reference count : 2</span></code></pre></figure>

<p>위의 코드를 통해 각자의 프로퍼티에 클래스 인스턴스를 할당해보자.<br /><br /> curry 인스턴스의 house 프로퍼티에 residenceHall을 할당하고, residenceHall 인스턴스의 nickname 프로퍼티에 curry를 할당하였다.<br /><br /></p>

<p><img width="786" alt="var curry" src="https://user-images.githubusercontent.com/83946704/169653234-c4ef188d-53a6-4066-b526-fb13b66d8e09.png" /><br />
(curry, residenceHall의 각각 프로퍼티 강한 참조 예시)<br /><br /></p>

<p>여기서 두 클래스 인스턴스에 대한 참조 카운트는 2가 된다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">curry</span> <span class="o">=</span> <span class="kc">nil</span> <span class="c1">// Learner reference count : 1</span>
<span class="n">residenceHall</span> <span class="o">=</span> <span class="kc">nil</span> <span class="c1">// Accommodation reference count : 1</span></code></pre></figure>

<p>이제 위의 코드와 같이 변수에 데이터를 할당 해제하면, 강한 참조가 하나 사라지게 되므로 참조 카운트는 1이 된다.</p>

<p><img width="752" alt="var curry" src="https://user-images.githubusercontent.com/83946704/169653298-af04f456-ecd1-43b0-b646-86b9be9034fb.png" /><br /></p>

<p>위의 그림과 같이 Learner 인스턴스와 Accommdation 인스턴스 사이의 강한 참조가 유지되어 필요 없는 데이터가 메모리에서 해제되지 않고 유지된다.</p>

<h2 id="5-resolving-strong-reference-cycles-between-class-instances">5. Resolving Strong Reference Cycles Between Class Instances</h2>
<p>위와 같은 강한참조의 메모리 문제를 해결하기 위해 weak 참조와 unowned 참조(소유되지 않은 참조)를 swift에서는 제공하고 있다. <br /><br />weak 참조와 unowned 참조를 사용하면 한 인스턴스가 강한 참조 주기를 만들지 않고도 참조를 할 수 있게 된다. <br /><br />또한 weak 참조나 unowned 참조를 사용하면 참조 카운트를 변화시키지 않기 때문에 메모리 누수가 발생하지 않는다.<br /><br /></p>

<h3 id="1-weak-references">1. Weak References</h3>
<p>weak 참조는 참조하는 인스턴스를 강하게 유지하지 않는 참조로 ARC가 참조된 인스턴스를 처리하는 것에 관여하지 않는다.<br /><br /> weak 참조를 사용하려면 weak 키워드를 사용해야 한다.<br /><br /> weak 참조로 인스턴스를 참조하고 있더라도 해당 인스턴스는 할당 해제될 수 있고 weak 참조를 nil로 설정한다.<br /><br /> 이렇게 값이 변경될 수 있기 때문에 weak 참조는 항상 상수가 아닌 변수로 선언해야 하며 옵셔널 타입이어야 한다.<br /><br /></p>

<p>위의 코드에서 나타난 문제를 weak 참조로 해결해보자.<br /><br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">Learner</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">nickname</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">house</span><span class="p">:</span> <span class="kt">Accommodation</span><span class="p">?</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">nickname</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span> <span class="k">self</span><span class="o">.</span><span class="n">nickname</span> <span class="o">=</span> <span class="n">nickname</span> <span class="p">}</span>

    <span class="kd">deinit</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">nickname</span><span class="se">)</span><span class="s"> is being deinitialized."</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Accommodation</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">weak</span> <span class="k">var</span> <span class="nv">nickname</span><span class="p">:</span> <span class="kt">Learner</span><span class="p">?</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span> <span class="k">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span> <span class="p">}</span>

    <span class="kd">deinit</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"Apartment </span><span class="se">\(</span><span class="n">type</span><span class="se">)</span><span class="s"> is being deinitialized."</span><span class="p">)}</span>
<span class="p">}</span></code></pre></figure>

<p>이전 코드에서 Accommodation 클래스의 nickname 프로퍼티에 Learner 클래스 인스턴스를 weak 참조로 참조하였다.<br /><br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">curry</span> <span class="o">=</span> <span class="kt">Learner</span><span class="p">(</span><span class="nv">nickname</span><span class="p">:</span> <span class="s">"커리"</span><span class="p">)</span> <span class="c1">// Learner reference count : 1</span>
<span class="n">residenceHall</span> <span class="o">=</span> <span class="kt">Accommodation</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="s">"생활관"</span><span class="p">)</span> <span class="c1">// Accommodation reference count : 1</span>

<span class="n">curry</span><span class="o">!.</span><span class="n">house</span> <span class="o">=</span> <span class="n">residenceHall</span> <span class="c1">// Accommodation reference count : 2</span>
<span class="n">residenceHall</span><span class="o">!.</span><span class="n">nickname</span> <span class="o">=</span> <span class="n">curry</span> <span class="c1">// Learner reference count : 1</span></code></pre></figure>

<p>전과 동일하게 curry, residenceHall 변수를 만들고 클래스 인스턴스를 할당하였다.<br /><br /> 그 뒤에 각자의 프로퍼티에 클래스 인스턴스를 할당한다.</p>

<p><img width="730" alt="var curry" src="https://user-images.githubusercontent.com/83946704/169653425-80c8ab44-a326-427a-9c55-0ea0d43dedab.png" /><br /></p>

<p>아까와 다르게 이번엔 weak 참조를 사용했기 때문에 위와 같은 구조가 변하게 된다.<br /><br />
여기서 curry 변수에 nil을 할당하게 된다면?<br /><br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">curry</span> <span class="o">=</span> <span class="kc">nil</span> <span class="c1">// Learner reference count : 0</span>
<span class="c1">// Accommodation reference count : 1</span>
<span class="c1">//prints "커리 is being deinitialized."</span></code></pre></figure>

<p><img width="725" alt="var curry" src="https://user-images.githubusercontent.com/83946704/169653464-029f10c4-8780-4e20-8cc4-76dd43d0feb1.png" /><br /></p>

<p>결과적으로 다음과 같이 Learner 인스턴스에 대한 강한 참조가 없게 되고 그 말은 참조 카운트가 0이란 것이므로 메모리에서 해제된다.<br /><br /> 또한 curry 변수가 메모리에서 할당 해제되며 Accommodation을 참조하던 house 프로퍼티도 사라졌기 때문에 Accommodation 인스턴스에 대한 강한 참조도 하나 사라지게 된다.<br /><br /> 그럼 이제 residenceHall에서 Accommodation 인스턴스에 대한 강한 참조만 남게 되고 아래의 코드를 통해 없애줄 수 있게 된다.<br /><br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">residenceHall</span> <span class="o">=</span> <span class="kc">nil</span> <span class="c1">// Accommodation reference count : 0</span>
<span class="c1">//prints "Apartment 생활관 is being deinitialized."</span></code></pre></figure>

<p><img width="746" alt="var curry" src="https://user-images.githubusercontent.com/83946704/169653497-e3d86841-cc9e-4022-8212-4f01284fb3f3.png" /><br /></p>

<p>결과적으로 모든 참조가 해제되고 참조 카운트도 0이 되어 메모리에서 해제된다.</p>

<h3 id="2-unowned-references">2. Unowned References</h3>
<p>weak 참조와 마찬가지로 unowned 참조도 인스턴스를 참조할 때 참조 카운트를 변경하지 않는다.<br /><br /> 하지만 weak 참조와 달리 unowned 참조는 참조한 어떠한 인스턴스의 수명이 동일하거나 더 길 때 사용하는데, 쉽게 말해 메모리 해제되지 않는다는 확신을 가지고 있을 때 사용해야한다.<br /><br /> 사용할 땐 unowned 키워드를 배치하여 사용할 수 있다.<br /><br /></p>

<p>메모리 해제가 되지 않을 것이란 확신이 들 때 사용해야 하기 때문에 약한 참조와는 달리 unowned 참조는 항상 값을 가져야 한다.<br /><br /> 따라서 옵셔널 타입이 될 수 없다.<br /><br /> 만약 unowned 참조로 참조한 인스턴스가 할당 해제되었는데 접근하려고 하면 당연하게도 런타임 오류가 발생한다.<br /><br /></p>

<p>unowned 참조를 어떻게 사용하는지 살펴보자.<br /><br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">Customer</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">card</span><span class="p">:</span> <span class="kt">CreditCard</span><span class="p">?</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>
    <span class="kd">deinit</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s"> is being deinitialized."</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">CreditCard</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">UInt64</span>
    <span class="k">unowned</span> <span class="k">let</span> <span class="nv">customer</span><span class="p">:</span> <span class="kt">Customer</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">UInt64</span><span class="p">,</span> <span class="nv">customer</span><span class="p">:</span> <span class="kt">Customer</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span>
        <span class="k">self</span><span class="o">.</span><span class="n">customer</span> <span class="o">=</span> <span class="n">customer</span>
    <span class="p">}</span>
    <span class="kd">deinit</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"Card #</span><span class="se">\(</span><span class="n">number</span><span class="se">)</span><span class="s"> is being deinitialized."</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>여기서 봐야할 점은 CreditCard 클래스의 customer 프로퍼티는 Customer 클래스의 인스턴스를 참조할 때 unowned 참조를 사용한다는 것이다.<br /><br /> 즉 CreditCard가 존재하는 한 Customer는 반드시 존재할 것이라는 확신이 있다는 것이다.<br /><br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nv">curry</span><span class="p">:</span> <span class="kt">Customer</span><span class="p">?</span>

<span class="n">curry</span> <span class="o">=</span> <span class="kt">Customer</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"커리"</span><span class="p">)</span>
<span class="n">curry</span><span class="o">!.</span><span class="n">card</span> <span class="o">=</span> <span class="kt">CreditCard</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="mi">1234_5678_9012_3456</span><span class="p">,</span> <span class="nv">customer</span><span class="p">:</span> <span class="n">curry</span><span class="o">!</span><span class="p">)</span></code></pre></figure>

<p>Curry 변수에 Customer 클래스 인스턴스를 할당한다. 그 뒤 CreditCard 인스턴스를 curry의 card 프로퍼티에 할당한다.</p>

<p><img width="867" alt="var curry" src="https://user-images.githubusercontent.com/83946704/169653630-f16fcde6-3d80-4d55-ad9a-3a9dcf4e3edd.png" /><br /></p>

<h2 id="5-마무리">5. 마무리</h2>
<p>Swift를 사용하다 자주 보이던 Subscript라는 키워드…<br />
<br />
항상 보일때마다 ‘나중에 공부해야지’ 라고 생각해놓고 미뤄두었는데 이번을 계기로 확실하게 개념과 사용방법을 익힌것 같다.<br />
<br />
그러니 앞으로도 모르는거 있으면 미리미리 하자!!</p>

<p><br /><br /><br /><br />
출처 : Swift 공식문서, Subscript<br />
(<a href="https://docs.swift.org/swift-book/LanguageGuide/Subscripts.html">https://docs.swift.org/swift-book/LanguageGuide/Subscripts.html</a>)<br />
참고 : 개발자 소들이, Swift) 서브스크립트(Subscript) 정복하기<br />
(<a href="https://babbab2.tistory.com/123">https://babbab2.tistory.com/123</a>)</p>
:ET