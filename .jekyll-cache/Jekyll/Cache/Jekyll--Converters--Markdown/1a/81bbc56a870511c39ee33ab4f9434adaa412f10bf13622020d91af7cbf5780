I"R]<h2 id="0-swift에서의-switch문">0. Swift에서의 switch문</h2>
<p>fallthrough를 알아보기 전, Swift에서의 switch문과 C에서의 switch문의 차이를 알아보자.<br />
<br />
C에서의 switch문은 각 case 마다 끝에 break문을 삽입하지 않으면 모든 case를 실행하게 된다<br />
<br />
하지만 Swift에서의 switch문은 각 case 조건에 일치하면 해당 case가 완료되자마자 실행을 종료한다.<br />
<br />
따라서, Swift의 switch문은 C에서와 같은 문제를 보완하여 더 간결하면서 예측 가능하고, 실수로 여러 case들을 실행하는 것을 피할 수 있는 장점을 가진다.<br />
<br /></p>

<h3 id="1-fallthrough">1. fallthrough</h3>
<p>위에서 알아봤듯, Swift의 switch문은 C에서의 switch문의 불편함을 해결하기 위해 다르게 만들어졌다.<br />
<br />
하지만 C에서와 비슷하게 동작하는 switch문을 필요로 할 수 있으므로, 대체하여 사용할 수 있도록 한 것이 <code class="language-plaintext highlighter-rouge">fallthrough</code>문 이다.<br /></p>

<p>아래 예제를 통해 알아보자.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="kt">CoffeeMachineType</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">iceAmericano</span>
    <span class="k">case</span> <span class="n">iceWater</span>
    <span class="k">case</span> <span class="n">water</span>

    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">iceAmericano</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"아이스 아메리카노🥤"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">iceWater</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"얼음물🧊"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">water</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"물💧"</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">selectMenu</span><span class="p">(</span><span class="nv">selectedMenu</span><span class="p">:</span> <span class="kt">CoffeeMachineType</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">selectedMenu</span><span class="o">.</span><span class="n">name</span><span class="se">)</span><span class="s">을 선택하셨습니다. 제조 시작하겠습니다..."</span><span class="p">)</span>
    <span class="k">switch</span> <span class="n">selectedMenu</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">iceAmericano</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"에스프레소 샷을 넣었습니다..."</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">iceWater</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"얼음을 넣었습니다..."</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">water</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"물을 넣었습니다..."</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"완성되었습니다, 맛있게드세요 !! 😄"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">selectMenu</span><span class="p">(</span><span class="nv">selectedMenu</span><span class="p">:</span> <span class="o">.</span><span class="n">iceAmericano</span><span class="p">)</span>

<span class="cp">#=&gt; prints 아이스 아메리카노🥤을 선택하셨습니다. 제조 시작하겠습니다...</span>
<span class="cp">#=&gt; prints 에스프레소 샷을 넣었습니다...</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">CoffeeMachineType</code> 타입의 enum을 선언하였다.<br />
<br />
그리고 <code class="language-plaintext highlighter-rouge">selectMenu</code>메소드를 통해 원하는 음료를 선택하면 선택한 음료와 제조과정이 나타난다.<br />
<br />
하지만 기존의 switch문을 그대로 사용했기 때문에 <code class="language-plaintext highlighter-rouge">.iceAmericano</code> case가 실행된 후 switch문이 완료됬음을 알 수 있다. <br />
<br />
나는 아아제조과정의 베이스가 되는 얼음을 넣는 과정과 물을 넣는 과정을 상위 case를 선택하였을 때도 넣고싶다.<br />
<br />
이러한 경우에 <code class="language-plaintext highlighter-rouge">fallthrough</code>문을 사용해보자.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">selectMenu</span><span class="p">(</span><span class="nv">selectedMenu</span><span class="p">:</span> <span class="kt">CoffeeMachineType</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">selectedMenu</span><span class="o">.</span><span class="n">name</span><span class="se">)</span><span class="s">을 선택하셨습니다. 제조 시작하겠습니다..."</span><span class="p">)</span>
    <span class="k">switch</span> <span class="n">selectedMenu</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">iceAmericano</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"에스프레소 샷을 넣습니다..."</span><span class="p">)</span>
        <span class="k">fallthrough</span>                   <span class="c1">// 다음 case 또한 포함할것이므로 fallthrough문 사용</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">iceWater</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"얼음을 넣습니다..."</span><span class="p">)</span>
        <span class="k">fallthrough</span>                   <span class="c1">// 다음 case 또한 포함할것이므로 fallthrough문 사용</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">water</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"물을 넣습니다..."</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"완성되었습니다, 맛있게드세요 !! 😄"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nf">selectMenu</span><span class="p">(</span><span class="nv">selectedMenu</span><span class="p">:</span> <span class="o">.</span><span class="n">iceAmericano</span><span class="p">)</span>

<span class="cp">#=&gt; prints 아이스 아메리카노🥤을 선택하셨습니다. 제조 시작하겠습니다...</span>
<span class="cp">#=&gt; prints 에스프레소 샷을 넣습니다...</span>
<span class="cp">#=&gt; prints 얼음을 넣습니다...</span>
<span class="cp">#=&gt; prints 물을 넣습니다...</span>
<span class="cp">#=&gt; prints 완성되었습니다, 맛있게드세요 !! 😄</span></code></pre></figure>

<h3 id="2-disposebag">2. DisposeBag</h3>
<p>구독해제를 <code class="language-plaintext highlighter-rouge">dispose()</code>로 한다고 알았는데… <code class="language-plaintext highlighter-rouge">DisposeBag</code>은 무엇일까?<br />
<br />
일단 코드를 통해 보도록 하자.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">disposeBag</span> <span class="o">=</span> <span class="kt">DisposeBag</span><span class="p">()</span>

<span class="kt">Observable</span><span class="o">.</span><span class="nf">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="o">.</span><span class="n">subscribe</span><span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>

<span class="cp">#=&gt; prints 아이스 아메리카노🥤을 선택하셨습니다. 제조 시작하겠습니다...</span>
<span class="cp">#=&gt; prints 에스프레소 샷을 넣었습니다...</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">disposed(by:)</code>는 <code class="language-plaintext highlighter-rouge">dispose()</code>와 동일하게 구독해제를 위해 작성하였다.<br />
<br />
<code class="language-plaintext highlighter-rouge">disposeBag</code>은 <code class="language-plaintext highlighter-rouge">disposed(by:)</code>를 통해 <code class="language-plaintext highlighter-rouge">disposable</code>타입으로 Observable을 받고, <code class="language-plaintext highlighter-rouge">disposeBag</code>이 할당해제를 할 때마다 담겨져 있는 모든 <code class="language-plaintext highlighter-rouge">disposable</code>들에게 <code class="language-plaintext highlighter-rouge">dispose()</code>를 호출한다.<br />
<br />
따라서 위 코드의 Observable은 발생하는 이벤트들을 print하고 구독 후 방출된 return 값들을 <code class="language-plaintext highlighter-rouge">disposeBag</code>에 추가하는 것이다.<br />
<br />
<code class="language-plaintext highlighter-rouge">dispose</code>와 <code class="language-plaintext highlighter-rouge">disposeBag</code>은 구독할 때 마다 할당하는 것 같아 불편해 보이지만, 끝나지 않는 Observable일 경우 메모리 누수가 일어나기 때문에 매번 Observable을 생성하면 <code class="language-plaintext highlighter-rouge">disposeBag</code>을 만드는게 무조건 필요하다.<br />
<br />
이후 하단의 예시에는 모두 <code class="language-plaintext highlighter-rouge">disposeBag</code>을 선언했다는 가정 하에 작성하도록 하겠다.</p>

<h2 id="1-create">1. create</h2>
<p><code class="language-plaintext highlighter-rouge">create</code>은 observer를 전달받아 <code class="language-plaintext highlighter-rouge">Disposable</code>을 반환하는 escaping 클로저이다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">// create 1</span>
<span class="kt">Observable</span><span class="o">.</span><span class="n">create</span> <span class="p">{</span> <span class="n">observer</span> <span class="o">-&gt;</span> <span class="kt">Disposable</span> <span class="k">in</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onCompleted</span><span class="p">()</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="kt">Disposables</span><span class="o">.</span><span class="nf">create</span><span class="p">()</span>
<span class="p">}</span>
<span class="o">.</span><span class="n">subscribe</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#=&gt; prints 1</span></code></pre></figure>

<p>다음과 같이 Observable을 생성하면 <code class="language-plaintext highlighter-rouge">1</code>만 출력된다. 이유는 무엇일까?<br />
<br />
바로 observer가 <code class="language-plaintext highlighter-rouge">1</code>을 next이벤트로 전달한 다음, completed이벤트를 통해 종료되어 그 다음 전달받은 element는 구독되지 않기 때문이다.<br />
<br />
그렇다면 completed이벤트와 유사하게 종료시키는 error이벤트는 어떻게 반응할까?</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">// create 2</span>
<span class="kd">enum</span> <span class="kt">MyError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">anError</span>
<span class="p">}</span>

<span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">create</span> <span class="p">{</span> <span class="n">observer</span> <span class="o">-&gt;</span> <span class="kt">Disposable</span> <span class="k">in</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onError</span><span class="p">(</span><span class="kt">MyError</span><span class="o">.</span><span class="n">anError</span><span class="p">)</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onCompleted</span><span class="p">()</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="kt">Disposables</span><span class="o">.</span><span class="nf">create</span><span class="p">()</span>
<span class="p">}</span>
<span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span>
    <span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onError</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"에러발생 : </span><span class="se">\(</span><span class="nv">$0</span><span class="o">.</span><span class="n">localizedDescription</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onCompleted</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"completed!"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onDisposed</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"disposed!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
<span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>

<span class="cp">#=&gt; prints 1</span>
<span class="cp">#=&gt; prints 에러발생 : The operation couldn’t be completed. (__lldb_expr_25.MyError error 0.)</span>
<span class="cp">#=&gt; prints disposed!</span></code></pre></figure>

<p>임의의 에러 <code class="language-plaintext highlighter-rouge">anError</code>를 생성한 후 <code class="language-plaintext highlighter-rouge">create</code>로 Observable을 생성하였다.<br />
<br />
처음 nex이벤트로 전달된 <code class="language-plaintext highlighter-rouge">1</code>은 무사히 출력되었지만 이후 에러가 발생하고 completed이벤트까지 가지않고, 2 또한 출력되지 않았다.<br />
하지만 Observable이 종료되고 <code class="language-plaintext highlighter-rouge">disposed</code>가 실행된 것은 확인할 수 있다.<br />
<br />
자 그럼 error, completed, disposed 모두 생성하지 않고 Observable을 만들면 어떻게 될까?</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">Observable</span><span class="o">.</span><span class="n">create</span> <span class="p">{</span> <span class="n">observer</span> <span class="o">-&gt;</span> <span class="kt">Disposable</span> <span class="k">in</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="kt">Disposables</span><span class="o">.</span><span class="nf">create</span><span class="p">()</span>
<span class="p">}</span>
<span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span>
    <span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onError</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"에러발생 : </span><span class="se">\(</span><span class="nv">$0</span><span class="o">.</span><span class="n">localizedDescription</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onCompleted</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"completed!"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">onDisposed</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"disposed!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="cp">#=&gt; prints 1</span>
<span class="cp">#=&gt; prints 2</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">disposed</code>, error, completed 이벤트 모두 없으므로 결과적으로 Observable은 종료되지 않고 메모리 누수가 발생할 것이다.<br />
<br />
따라서 반드시 Observable을 생성할 땐 <code class="language-plaintext highlighter-rouge">disposed</code>를 작성해주도록 하자.</p>

<h2 id="2-deferred">2. deferred</h2>
<p>deferred는 Observable을 만드는 대신에, 구독이 되기 전까지 Observable 생성을 지연하고 구독이 시작되면 새롭게 Observable을 제공하는 Observable Factory 형식이다.<br />
<br />
굉장히 이해하기 어려운 내용인데, 쉽게 풀어보면</p>
<ol>
  <li>구독하기 전엔 ‘대기상태의 Observable’</li>
  <li>구독을 시작하면 ‘진짜로 생성된 Observable’<br />
<br />
예시를 통해 확인하자.</li>
</ol>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nv">뒤집기</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span>

<span class="k">let</span> <span class="nv">factory</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Observable</span><span class="o">.</span><span class="n">deferred</span> <span class="p">{</span>
    <span class="n">뒤집기</span> <span class="o">=</span> <span class="o">!</span><span class="n">뒤집기</span>

    <span class="k">if</span> <span class="n">뒤집기</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Observable</span><span class="o">.</span><span class="nf">of</span><span class="p">(</span><span class="s">"👍"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Observable</span><span class="o">.</span><span class="nf">of</span><span class="p">(</span><span class="s">"👎"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="mi">3</span> <span class="p">{</span>
    <span class="n">factory</span><span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
    <span class="p">})</span>
        <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#=&gt; prints 👍</span>
<span class="cp">#=&gt; prints 👎</span>
<span class="cp">#=&gt; prints 👍</span>
<span class="cp">#=&gt; prints 👎</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">factory</code>는 처음 선언될 때 <code class="language-plaintext highlighter-rouge">deferred</code>된 Observable로 선언되었기 때문에 대기상태이다.<br />
<br />
그리고 Bool 타입인 <code class="language-plaintext highlighter-rouge">뒤집기</code> 변수는 처음엔 <code class="language-plaintext highlighter-rouge">false</code>이다.<br />
<br />
이후 구독됨에 따라 <code class="language-plaintext highlighter-rouge">factory</code>는 대기상태가 풀리면서 <code class="language-plaintext highlighter-rouge">deferred</code>내의 <code class="language-plaintext highlighter-rouge">뒤집기 = !뒤집기</code>가 실행되었기 때문에 <code class="language-plaintext highlighter-rouge">뒤집기 = true</code>가 되고, <code class="language-plaintext highlighter-rouge">👍</code>이 출력된다.<br />
<br />
그 다음 반복에서도 위와 같은 과정으로 <code class="language-plaintext highlighter-rouge">뒤집기</code>의 Bool값이 변하면서 출력된다.<br />
<br />
다시한번 정리하자면, Observable deferred는 Observable factory를 통해서 sequence를 생성할 수 있는 연산자이다.</p>

<h2 id="3-마무리">3. 마무리</h2>
<p>지금까지 두개의 포스팅을 통해 Observable의 기본이 되는 생성 Operator들과 dispose에 대해 알아보았다.<br />
<br />
다음은 Observable보다 조금 작은 개념인 Single, Maybe, Completable에 대해 알아보도록 하자.</p>

<p><br /><br /><br /><br />
출처 : 30개 프로젝트로 배우는 iOS 앱 개발 with Swift 초격차 패키지 Online - part 4. Github 앱 만들기</p>
:ET